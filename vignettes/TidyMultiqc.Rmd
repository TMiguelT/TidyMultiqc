---
title: "TidyMultiqc"
output:
  html_document:
    toc: true
    toc_depth: 3
    df_print: paged
pkgdown:
  as_is: true
vignette: >
  %\VignetteIndexEntry{TidyMultiqc}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
  %\Vignette
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
multiqc_data_path = system.file("extdata", "wgs/multiqc_data.json", package = "TidyMultiqc")
```

## Test Data
In this example we'll be using the WGS example report used in the MultiQC 
documentation. You can find view the report in your browser [here](https://multiqc.info/examples/wgs/multiqc_report.html),
and find the associated `multiqc_data.json` file [here](https://github.com/ewels/MultiQC_website/blob/master/public_html/examples/wgs/multiqc_data/multiqc_data.json).
Feel free to download this file and use it to follow along with this vignette.

In the rest of the vignette we will use the `multiqc_data_path` variable
to indicate the path to this `multiqc_data.json` file. Feel free to set this 
variable to the path to this file on your system.

## Setup
First, install the package using:
```{r, eval=FALSE}
install.packages("TidyMultiqc")
```

Then load the package:
```{r setup}
library(TidyMultiqc)
```

## Basic Usage
The main entry point to the `TidyMultiqc` package is the function `load_multiqc`.
A basic invocation of this function looks like this:

(note the arrow for scrolling through columns)
```{r paged.print=TRUE}
df = load_multiqc(multiqc_data_path)
df
```
We've now generated a `tibble` (a kind of data frame), whose rows are samples in the QC report, and whose columns are QC data and metadata about these samples.

By default this function only returns the "general" statistics, which are the ones in the "General Statistics" table at the top of the MultiQC report.
In TidyMultiqc, these statistics are all prefixed by `general.`
We can also extract the "raw" statistics, which includes some fields normally hidden from the report.
These statistics will have the prefix `raw.<toolname>.` where `<toolname>` is the QC tool used to calculate it.

```{r}
load_multiqc(multiqc_data_path, sections = 'raw')
```
Often you won't care about fields like `raw.qualimap_bamqc_genome_results.bam_file`, the path to the original BAM file, but 'raw' at least provides this option.

You can also combine both `general` and `raw` sections by passing in a longer vector:

```{r}
df_both = load_multiqc(multiqc_data_path, sections = c('raw', 'general'))
ncol(df_both)
```
That's a lot of columns!

## Uses

This section will briefly talk about some downstream use-cases for this package.

### Plotting

One use for this data frame is creating QC plots. For example, to visualise the duplication rate per sample:

```{r}
library(ggplot2)

ggplot(df, aes(x=metadata.sample_id, y=general.percent_duplication)) + geom_col()
```

Of course, this is basically just replicating a plot already in the MultiQC report, but now we can customise it how we like!

### Hypothesis Testing

With all this data, we might also want to test a specific hypothesis! For example, we might want to test the hypothesis that the mean GC content is the same as the mean GC content in the human genome (41%). If we assume that GC content is normally distributed, we can do the following:
```{r}
t.test(df$general.percent_gc, mu=41)
```
It seems that we cannot reject this hypothesis, so these may well be human samples!

## Extracting Plot Data

### Motivation

It is occasionally useful to extract QC data from the MultiQC plots. 
For example, let's say we want to calculate the median quality score of every base in each sample.
Unfortunately, MultiQC provides no numerical summary statistic for the mean read quality, it only has mapping quality and pass/fails for the per-base sequence quality:

```{r message=FALSE, warning=FALSE}
library(dplyr)

df_both %>% select(contains('quality'))
```

However, our MultiQC report does have *plots* that contain this information.
In particular, let's look at the "Per Sequence Quality Scores" plot.

### Listing Plots

Firstly, we need the ID of the plot we want.
This isn't necessarily obvious from just looking at the report, so we can use a utility function here:

```{r}
list_plots(multiqc_data_path)
```

Now, we know we want the "Per Sequence Quality Scores" plot, and by looking at the data frame above we can tell that the corresponding ID is `fastqc_per_sequence_quality_scores_plot`.

### Loading Plots

Now that we have the plot ID, we can load the plot data.
First, we need to tell `TidyMultiqc` to load include some plots by using `sections = "plot"` (you can load other sections at the same time, as explained above).
Also, we need to pass the plot ID from the previous step into the `plots` argument:
```{r}
df = load_multiqc(
  multiqc_data_path, 
  sections = 'plot',
  plots = "fastqc_per_sequence_quality_scores_plot"
)
df
```

We now have the plot data, but it's not in a very usable form! 
This is because each sample has an entire data frame of plot data.
At this point if you're comfortable using `dplyr` and `tidyr` to deal with nested data frames, you probably know what to do.
Otherwise, read on.

### Converting Plot Data

Recall that we are after the median quality score of each sample.
First, we should look at the plot data for a single sample to know what we're dealing with:

```{r}
df$plot.fastqc_per_sequence_quality_scores_plot[[1]]
```
So each data frame is a set of x, y pairs. 
As it's a histogram plot, we know that the `x` value is the quality score, and `y` is the number of times that score has been counted.

Now, if we just wanted a simple statistic, like the number of times the quality score was 30 (not a very useful metric in reality), we could pull out this value from the data frame.
But remember, we are actually dealing with a list of data frames, so we will have to use a `purrr::map` function to help here:

```{r}
library(purrr)

df %>%
  mutate(q30s = purrr::map_dbl(plot.fastqc_per_sequence_quality_scores_plot, function(plot_df){
    plot_df %>%
      filter(x == 30) %>%
      pull(y)
  }))
```

Note as well that we used `purrr::map_dbl` here, since the final column was a double-typed vector.

### Properly Handling Histogram Data

Of course, we actually want to find the median here, which is a bit harder.
Luckily there exists a package called `HistDat` for generating summary statistics from histogram-type data.
You can check out the package's manual and vignettes [here](https://cran.r-project.org/package=HistDat), but in brief, we want to convert each of these plot data frames into a `HistDat` object, which we can do using the same strategy as before, only we use `purrr::map` because we want a list column.
We can also throw away the original plot column, because we no longer need it:

```{r}
library(HistDat)

df = df %>%
  dplyr::mutate(
    hist = purrr::map(plot.fastqc_per_sequence_quality_scores_plot, function(plot_df){
      HistDat(vals=plot_df$x, counts = plot_df$y)
    }),
    plot.fastqc_per_sequence_quality_scores_plot = NULL
  )
```
Finally, we can now apply one or more summary statistics to this new column:

```{r}
df %>%
  mutate(
    mean = purrr::map_dbl(hist, mean),
    median = purrr::map_dbl(hist, median),
    max = purrr::map_dbl(hist, max),
    q30s = NULL,
    hist = NULL
  )
```

Perfect!